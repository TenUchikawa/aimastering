/**
 * AI Mastering API
 * This is a AI Mastering API document. You can use the mastering feature of [AI Mastering](https://aimastering.com) through this API.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: info@bakuage.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.bakuage.com:443';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AccessToken {
    'accessToken'?: JWT;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "access_token",
            "type": "JWT"
        }    ];

    static getAttributeTypeMap() {
        return AccessToken.attributeTypeMap;
    }
}

export class AmazonSubscription {
    'id'?: number;
    'userId'?: number;
    'status'?: AmazonSubscription.StatusEnum;
    'createdAt'?: Date;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "AmazonSubscription.StatusEnum"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return AmazonSubscription.attributeTypeMap;
    }
}

export namespace AmazonSubscription {
    export enum StatusEnum {
        Active = <any> 'active',
        Deactivated = <any> 'deactivated'
    }
}
export class AnonymizedMastering {
    'userId'?: string;
    'userAuthProvider'?: string;
    'mode'?: AnonymizedMastering.ModeEnum;
    'status'?: AnonymizedMastering.StatusEnum;
    'failureReason'?: AnonymizedMastering.FailureReasonEnum;
    'targetLoudness'?: number;
    'outputFormat'?: AnonymizedMastering.OutputFormatEnum;
    'preset'?: AnonymizedMastering.PresetEnum;
    'bitDepth'?: number;
    'sampleRate'?: number;
    'reviewScore'?: number;
    'masteringMatchingLevel'?: number;
    'mastering'?: boolean;
    'paid'?: boolean;
    'paymentService'?: AnonymizedMastering.PaymentServiceEnum;
    'retryCount'?: number;
    'masteringReverb'?: boolean;
    'masteringReverbGain'?: number;
    'lowCutFreq'?: number;
    'highCutFreq'?: number;
    'createdAt'?: Date;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "string"
        },
        {
            "name": "userAuthProvider",
            "baseName": "user_auth_provider",
            "type": "string"
        },
        {
            "name": "mode",
            "baseName": "mode",
            "type": "AnonymizedMastering.ModeEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "AnonymizedMastering.StatusEnum"
        },
        {
            "name": "failureReason",
            "baseName": "failure_reason",
            "type": "AnonymizedMastering.FailureReasonEnum"
        },
        {
            "name": "targetLoudness",
            "baseName": "target_loudness",
            "type": "number"
        },
        {
            "name": "outputFormat",
            "baseName": "output_format",
            "type": "AnonymizedMastering.OutputFormatEnum"
        },
        {
            "name": "preset",
            "baseName": "preset",
            "type": "AnonymizedMastering.PresetEnum"
        },
        {
            "name": "bitDepth",
            "baseName": "bit_depth",
            "type": "number"
        },
        {
            "name": "sampleRate",
            "baseName": "sample_rate",
            "type": "number"
        },
        {
            "name": "reviewScore",
            "baseName": "review_score",
            "type": "number"
        },
        {
            "name": "masteringMatchingLevel",
            "baseName": "mastering_matching_level",
            "type": "number"
        },
        {
            "name": "mastering",
            "baseName": "mastering",
            "type": "boolean"
        },
        {
            "name": "paid",
            "baseName": "paid",
            "type": "boolean"
        },
        {
            "name": "paymentService",
            "baseName": "payment_service",
            "type": "AnonymizedMastering.PaymentServiceEnum"
        },
        {
            "name": "retryCount",
            "baseName": "retry_count",
            "type": "number"
        },
        {
            "name": "masteringReverb",
            "baseName": "mastering_reverb",
            "type": "boolean"
        },
        {
            "name": "masteringReverbGain",
            "baseName": "mastering_reverb_gain",
            "type": "number"
        },
        {
            "name": "lowCutFreq",
            "baseName": "low_cut_freq",
            "type": "number"
        },
        {
            "name": "highCutFreq",
            "baseName": "high_cut_freq",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return AnonymizedMastering.attributeTypeMap;
    }
}

export namespace AnonymizedMastering {
    export enum ModeEnum {
        Default = <any> 'default',
        Custom = <any> 'custom'
    }
    export enum StatusEnum {
        Waiting = <any> 'waiting',
        Processing = <any> 'processing',
        Canceled = <any> 'canceled',
        Failed = <any> 'failed',
        Succeeded = <any> 'succeeded'
    }
    export enum FailureReasonEnum {
        Unknown = <any> 'unknown',
        Expired = <any> 'expired',
        FailedToPrepare = <any> 'failed_to_prepare'
    }
    export enum OutputFormatEnum {
        Wav = <any> 'wav',
        Mp3 = <any> 'mp3'
    }
    export enum PresetEnum {
        General = <any> 'general',
        Pop = <any> 'pop',
        Jazz = <any> 'jazz',
        Classical = <any> 'classical'
    }
    export enum PaymentServiceEnum {
        Paypal = <any> 'paypal',
        Stripe = <any> 'stripe'
    }
}
export class Audio {
    'id'?: number;
    'fileResourceId'?: number;
    'userId'?: number;
    'name'?: string;
    'createdByUser'?: boolean;
    'status'?: string;
    'failureReason'?: string;
    'probeJson'?: string;
    'rms'?: number;
    'peak'?: number;
    'truePeak'?: number;
    'lowpassTruePeak15khz'?: number;
    'loudness'?: number;
    'dynamics'?: number;
    'sharpness'?: number;
    'space'?: number;
    'loudnessRange'?: number;
    'drr'?: number;
    'soundQuality'?: number;
    'soundQuality2'?: number;
    'dissonance'?: number;
    'frames'?: number;
    'sampleRate'?: number;
    'channels'?: number;
    'createdAt'?: Date;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "fileResourceId",
            "baseName": "file_resource_id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "createdByUser",
            "baseName": "created_by_user",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "failureReason",
            "baseName": "failure_reason",
            "type": "string"
        },
        {
            "name": "probeJson",
            "baseName": "probe_json",
            "type": "string"
        },
        {
            "name": "rms",
            "baseName": "rms",
            "type": "number"
        },
        {
            "name": "peak",
            "baseName": "peak",
            "type": "number"
        },
        {
            "name": "truePeak",
            "baseName": "true_peak",
            "type": "number"
        },
        {
            "name": "lowpassTruePeak15khz",
            "baseName": "lowpass_true_peak_15khz",
            "type": "number"
        },
        {
            "name": "loudness",
            "baseName": "loudness",
            "type": "number"
        },
        {
            "name": "dynamics",
            "baseName": "dynamics",
            "type": "number"
        },
        {
            "name": "sharpness",
            "baseName": "sharpness",
            "type": "number"
        },
        {
            "name": "space",
            "baseName": "space",
            "type": "number"
        },
        {
            "name": "loudnessRange",
            "baseName": "loudness_range",
            "type": "number"
        },
        {
            "name": "drr",
            "baseName": "drr",
            "type": "number"
        },
        {
            "name": "soundQuality",
            "baseName": "sound_quality",
            "type": "number"
        },
        {
            "name": "soundQuality2",
            "baseName": "sound_quality2",
            "type": "number"
        },
        {
            "name": "dissonance",
            "baseName": "dissonance",
            "type": "number"
        },
        {
            "name": "frames",
            "baseName": "frames",
            "type": "number"
        },
        {
            "name": "sampleRate",
            "baseName": "sample_rate",
            "type": "number"
        },
        {
            "name": "channels",
            "baseName": "channels",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Audio.attributeTypeMap;
    }
}

export class AudioAnalysis {
    /**
    * Audio analysis id
    */
    'id'?: number;
    /**
    * Audio id
    */
    'audioId'?: number;
    /**
    * Audio analysis data. The schema changes frequently.
    */
    'analysis'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "audioId",
            "baseName": "audio_id",
            "type": "number"
        },
        {
            "name": "analysis",
            "baseName": "analysis",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return AudioAnalysis.attributeTypeMap;
    }
}

export class AudioDownloadToken {
    'downloadToken'?: JWT;
    'downloadUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "JWT"
        },
        {
            "name": "downloadUrl",
            "baseName": "download_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AudioDownloadToken.attributeTypeMap;
    }
}

export class Config {
    'auth0'?: ConfigAuth0;
    'paypal'?: ConfigPaypal;
    'stripe'?: ConfigStripe;
    'version'?: ConfigVersion;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auth0",
            "baseName": "auth0",
            "type": "ConfigAuth0"
        },
        {
            "name": "paypal",
            "baseName": "paypal",
            "type": "ConfigPaypal"
        },
        {
            "name": "stripe",
            "baseName": "stripe",
            "type": "ConfigStripe"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "ConfigVersion"
        }    ];

    static getAttributeTypeMap() {
        return Config.attributeTypeMap;
    }
}

export class ConfigAuth0 {
    'audience'?: string;
    'domain'?: string;
    'clientId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "audience",
            "baseName": "audience",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConfigAuth0.attributeTypeMap;
    }
}

export class ConfigPaypal {
    'mode'?: string;
    'clientId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mode",
            "baseName": "mode",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConfigPaypal.attributeTypeMap;
    }
}

export class ConfigStripe {
    'publishableKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "publishableKey",
            "baseName": "publishable_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConfigStripe.attributeTypeMap;
    }
}

export class ConfigVersion {
    'commit'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commit",
            "baseName": "commit",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConfigVersion.attributeTypeMap;
    }
}

export class ExternalSearchResult {
    'itunes'?: Array<ExternalSearchResultItunes>;
    'youtube'?: Array<ExternalSearchResultYoutube>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itunes",
            "baseName": "itunes",
            "type": "Array<ExternalSearchResultItunes>"
        },
        {
            "name": "youtube",
            "baseName": "youtube",
            "type": "Array<ExternalSearchResultYoutube>"
        }    ];

    static getAttributeTypeMap() {
        return ExternalSearchResult.attributeTypeMap;
    }
}

export class ExternalSearchResultItunes {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'url'?: string;
    'thumbnailUrl'?: string;
    'previewUrl'?: string;
    'albumName'?: string;
    'albumUrl'?: string;
    'artistName'?: string;
    'artistUrl'?: string;
    'trackNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "thumbnailUrl",
            "baseName": "thumbnail_url",
            "type": "string"
        },
        {
            "name": "previewUrl",
            "baseName": "preview_url",
            "type": "string"
        },
        {
            "name": "albumName",
            "baseName": "album_name",
            "type": "string"
        },
        {
            "name": "albumUrl",
            "baseName": "album_url",
            "type": "string"
        },
        {
            "name": "artistName",
            "baseName": "artist_name",
            "type": "string"
        },
        {
            "name": "artistUrl",
            "baseName": "artist_url",
            "type": "string"
        },
        {
            "name": "trackNumber",
            "baseName": "track_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ExternalSearchResultItunes.attributeTypeMap;
    }
}

export class ExternalSearchResultYoutube {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'url'?: string;
    'thumbnailUrl'?: string;
    'channelId'?: string;
    'channelUrl'?: string;
    'channelName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "thumbnailUrl",
            "baseName": "thumbnail_url",
            "type": "string"
        },
        {
            "name": "channelId",
            "baseName": "channel_id",
            "type": "string"
        },
        {
            "name": "channelUrl",
            "baseName": "channel_url",
            "type": "string"
        },
        {
            "name": "channelName",
            "baseName": "channel_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExternalSearchResultYoutube.attributeTypeMap;
    }
}

export class GroupBuyStatistics {
    'premiumPlanSubscribedUserCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "premiumPlanSubscribedUserCount",
            "baseName": "premium_plan_subscribed_user_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GroupBuyStatistics.attributeTypeMap;
    }
}

export class JWT {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return JWT.attributeTypeMap;
    }
}

export class Kpi {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Kpi.attributeTypeMap;
    }
}

export class LibraryAudio {
    'id'?: number;
    'userId'?: number;
    'name'?: string;
    'album'?: string;
    'albumArtist'?: string;
    'artist'?: string;
    'genre'?: string;
    'track'?: number;
    'publisher'?: string;
    'fileHash'?: string;
    'size'?: number;
    'status'?: string;
    'failureReason'?: string;
    'probeJson'?: string;
    'rms'?: number;
    'peak'?: number;
    'truePeak'?: number;
    'lowpassTruePeak15khz'?: number;
    'loudness'?: number;
    'dynamics'?: number;
    'sharpness'?: number;
    'space'?: number;
    'loudnessRange'?: number;
    'drr'?: number;
    'soundQuality'?: number;
    'soundQuality2'?: number;
    'dissonance'?: number;
    'frames'?: number;
    'sampleRate'?: number;
    'channels'?: number;
    'isPublic'?: boolean;
    'likedBySelf'?: boolean;
    'likeCount'?: number;
    'createdAt'?: Date;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "album",
            "baseName": "album",
            "type": "string"
        },
        {
            "name": "albumArtist",
            "baseName": "album_artist",
            "type": "string"
        },
        {
            "name": "artist",
            "baseName": "artist",
            "type": "string"
        },
        {
            "name": "genre",
            "baseName": "genre",
            "type": "string"
        },
        {
            "name": "track",
            "baseName": "track",
            "type": "number"
        },
        {
            "name": "publisher",
            "baseName": "publisher",
            "type": "string"
        },
        {
            "name": "fileHash",
            "baseName": "file_hash",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "failureReason",
            "baseName": "failure_reason",
            "type": "string"
        },
        {
            "name": "probeJson",
            "baseName": "probe_json",
            "type": "string"
        },
        {
            "name": "rms",
            "baseName": "rms",
            "type": "number"
        },
        {
            "name": "peak",
            "baseName": "peak",
            "type": "number"
        },
        {
            "name": "truePeak",
            "baseName": "true_peak",
            "type": "number"
        },
        {
            "name": "lowpassTruePeak15khz",
            "baseName": "lowpass_true_peak_15khz",
            "type": "number"
        },
        {
            "name": "loudness",
            "baseName": "loudness",
            "type": "number"
        },
        {
            "name": "dynamics",
            "baseName": "dynamics",
            "type": "number"
        },
        {
            "name": "sharpness",
            "baseName": "sharpness",
            "type": "number"
        },
        {
            "name": "space",
            "baseName": "space",
            "type": "number"
        },
        {
            "name": "loudnessRange",
            "baseName": "loudness_range",
            "type": "number"
        },
        {
            "name": "drr",
            "baseName": "drr",
            "type": "number"
        },
        {
            "name": "soundQuality",
            "baseName": "sound_quality",
            "type": "number"
        },
        {
            "name": "soundQuality2",
            "baseName": "sound_quality2",
            "type": "number"
        },
        {
            "name": "dissonance",
            "baseName": "dissonance",
            "type": "number"
        },
        {
            "name": "frames",
            "baseName": "frames",
            "type": "number"
        },
        {
            "name": "sampleRate",
            "baseName": "sample_rate",
            "type": "number"
        },
        {
            "name": "channels",
            "baseName": "channels",
            "type": "number"
        },
        {
            "name": "isPublic",
            "baseName": "is_public",
            "type": "boolean"
        },
        {
            "name": "likedBySelf",
            "baseName": "liked_by_self",
            "type": "boolean"
        },
        {
            "name": "likeCount",
            "baseName": "like_count",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return LibraryAudio.attributeTypeMap;
    }
}

export class LibraryAudioAnalysis {
    /**
    * Audio analysis id
    */
    'id'?: number;
    /**
    * Audio id
    */
    'libraryAudioId'?: number;
    /**
    * Audio analysis data. The schema changes frequently.
    */
    'analysis'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "libraryAudioId",
            "baseName": "library_audio_id",
            "type": "number"
        },
        {
            "name": "analysis",
            "baseName": "analysis",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return LibraryAudioAnalysis.attributeTypeMap;
    }
}

export class LibraryAudioLike {
    /**
    * Audio analysis id
    */
    'id'?: number;
    /**
    * Audio id
    */
    'libraryAudioId'?: number;
    /**
    * User id
    */
    'userId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "libraryAudioId",
            "baseName": "library_audio_id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LibraryAudioLike.attributeTypeMap;
    }
}

export class Mastering {
    'id'?: number;
    'userId'?: number;
    'inputAudioId'?: number;
    'outputAudioId'?: number;
    'outputVideoId'?: number;
    'referenceAudioId'?: number;
    'mode'?: Mastering.ModeEnum;
    'status'?: Mastering.StatusEnum;
    'failureReason'?: Mastering.FailureReasonEnum;
    'targetLoudnessMode'?: Mastering.TargetLoudnessModeEnum;
    'targetLoudness'?: number;
    'outputFormat'?: Mastering.OutputFormatEnum;
    'preset'?: Mastering.PresetEnum;
    'bitDepth'?: number;
    'sampleRate'?: number;
    'reviewComment'?: string;
    'reviewScore'?: number;
    'masteringMatchingLevel'?: number;
    'progression'?: number;
    'bassPreservation'?: boolean;
    'mastering'?: boolean;
    'masteringAlgorithm'?: Mastering.MasteringAlgorithmEnum;
    'preserved'?: boolean;
    'retryCount'?: number;
    'masteringReverb'?: boolean;
    'masteringReverbGain'?: number;
    'lowCutFreq'?: number;
    'highCutFreq'?: number;
    'ceiling'?: number;
    'ceilingMode'?: string;
    'oversample'?: number;
    'limitingError'?: number;
    'videoTitle'?: string;
    'videoStatus'?: Mastering.VideoStatusEnum;
    'expireAt'?: Date;
    'createdAt'?: Date;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "inputAudioId",
            "baseName": "input_audio_id",
            "type": "number"
        },
        {
            "name": "outputAudioId",
            "baseName": "output_audio_id",
            "type": "number"
        },
        {
            "name": "outputVideoId",
            "baseName": "output_video_id",
            "type": "number"
        },
        {
            "name": "referenceAudioId",
            "baseName": "reference_audio_id",
            "type": "number"
        },
        {
            "name": "mode",
            "baseName": "mode",
            "type": "Mastering.ModeEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Mastering.StatusEnum"
        },
        {
            "name": "failureReason",
            "baseName": "failure_reason",
            "type": "Mastering.FailureReasonEnum"
        },
        {
            "name": "targetLoudnessMode",
            "baseName": "target_loudness_mode",
            "type": "Mastering.TargetLoudnessModeEnum"
        },
        {
            "name": "targetLoudness",
            "baseName": "target_loudness",
            "type": "number"
        },
        {
            "name": "outputFormat",
            "baseName": "output_format",
            "type": "Mastering.OutputFormatEnum"
        },
        {
            "name": "preset",
            "baseName": "preset",
            "type": "Mastering.PresetEnum"
        },
        {
            "name": "bitDepth",
            "baseName": "bit_depth",
            "type": "number"
        },
        {
            "name": "sampleRate",
            "baseName": "sample_rate",
            "type": "number"
        },
        {
            "name": "reviewComment",
            "baseName": "review_comment",
            "type": "string"
        },
        {
            "name": "reviewScore",
            "baseName": "review_score",
            "type": "number"
        },
        {
            "name": "masteringMatchingLevel",
            "baseName": "mastering_matching_level",
            "type": "number"
        },
        {
            "name": "progression",
            "baseName": "progression",
            "type": "number"
        },
        {
            "name": "bassPreservation",
            "baseName": "bass_preservation",
            "type": "boolean"
        },
        {
            "name": "mastering",
            "baseName": "mastering",
            "type": "boolean"
        },
        {
            "name": "masteringAlgorithm",
            "baseName": "mastering_algorithm",
            "type": "Mastering.MasteringAlgorithmEnum"
        },
        {
            "name": "preserved",
            "baseName": "preserved",
            "type": "boolean"
        },
        {
            "name": "retryCount",
            "baseName": "retry_count",
            "type": "number"
        },
        {
            "name": "masteringReverb",
            "baseName": "mastering_reverb",
            "type": "boolean"
        },
        {
            "name": "masteringReverbGain",
            "baseName": "mastering_reverb_gain",
            "type": "number"
        },
        {
            "name": "lowCutFreq",
            "baseName": "low_cut_freq",
            "type": "number"
        },
        {
            "name": "highCutFreq",
            "baseName": "high_cut_freq",
            "type": "number"
        },
        {
            "name": "ceiling",
            "baseName": "ceiling",
            "type": "number"
        },
        {
            "name": "ceilingMode",
            "baseName": "ceiling_mode",
            "type": "string"
        },
        {
            "name": "oversample",
            "baseName": "oversample",
            "type": "number"
        },
        {
            "name": "limitingError",
            "baseName": "limiting_error",
            "type": "number"
        },
        {
            "name": "videoTitle",
            "baseName": "video_title",
            "type": "string"
        },
        {
            "name": "videoStatus",
            "baseName": "video_status",
            "type": "Mastering.VideoStatusEnum"
        },
        {
            "name": "expireAt",
            "baseName": "expire_at",
            "type": "Date"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Mastering.attributeTypeMap;
    }
}

export namespace Mastering {
    export enum ModeEnum {
        Default = <any> 'default',
        Custom = <any> 'custom'
    }
    export enum StatusEnum {
        Waiting = <any> 'waiting',
        Processing = <any> 'processing',
        Canceled = <any> 'canceled',
        Failed = <any> 'failed',
        Succeeded = <any> 'succeeded'
    }
    export enum FailureReasonEnum {
        Unknown = <any> 'unknown',
        Expired = <any> 'expired',
        FailedToPrepare = <any> 'failed_to_prepare'
    }
    export enum TargetLoudnessModeEnum {
        Loudness = <any> 'loudness',
        Rms = <any> 'rms',
        Peak = <any> 'peak',
        YoutubeLoudness = <any> 'youtube_loudness'
    }
    export enum OutputFormatEnum {
        Wav = <any> 'wav',
        Mp3 = <any> 'mp3'
    }
    export enum PresetEnum {
        General = <any> 'general',
        Pop = <any> 'pop',
        Jazz = <any> 'jazz',
        Classical = <any> 'classical'
    }
    export enum MasteringAlgorithmEnum {
        V1 = <any> 'v1',
        V2 = <any> 'v2'
    }
    export enum VideoStatusEnum {
        Waiting = <any> 'waiting',
        Failed = <any> 'failed',
        Succeeded = <any> 'succeeded'
    }
}
export class Payment {
    'id'?: number;
    'service'?: Payment.ServiceEnum;
    'productGiven'?: boolean;
    'product'?: any;
    'transactionId'?: string;
    'transactionDetail'?: any;
    'createdAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "service",
            "baseName": "service",
            "type": "Payment.ServiceEnum"
        },
        {
            "name": "productGiven",
            "baseName": "product_given",
            "type": "boolean"
        },
        {
            "name": "product",
            "baseName": "product",
            "type": "any"
        },
        {
            "name": "transactionId",
            "baseName": "transaction_id",
            "type": "string"
        },
        {
            "name": "transactionDetail",
            "baseName": "transaction_detail",
            "type": "any"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Payment.attributeTypeMap;
    }
}

export namespace Payment {
    export enum ServiceEnum {
        Paypal = <any> 'paypal',
        Stripe = <any> 'stripe'
    }
}
export class PaymentCustomer {
    'id'?: number;
    'paymentCustomerDetail'?: any;
    'createdAt'?: Date;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "paymentCustomerDetail",
            "baseName": "payment_customer_detail",
            "type": "any"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PaymentCustomer.attributeTypeMap;
    }
}

export class Plan {
    'amount'?: number;
    'currency'?: Plan.CurrencyEnum;
    'interval'?: Plan.IntervalEnum;
    'name'?: string;
    'stripePlanId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "Plan.CurrencyEnum"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "Plan.IntervalEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "stripePlanId",
            "baseName": "stripe_plan_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Plan.attributeTypeMap;
    }
}

export namespace Plan {
    export enum CurrencyEnum {
        Jpy = <any> 'jpy',
        Usd = <any> 'usd'
    }
    export enum IntervalEnum {
        Month = <any> 'month'
    }
}
export class SpSubscription {
    'id'?: number;
    'userId'?: number;
    'status'?: SpSubscription.StatusEnum;
    'createdAt'?: Date;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "SpSubscription.StatusEnum"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return SpSubscription.attributeTypeMap;
    }
}

export namespace SpSubscription {
    export enum StatusEnum {
        Active = <any> 'active',
        Inactive = <any> 'inactive'
    }
}
export class Subscription {
    'id'?: number;
    'userId'?: number;
    'stripeSubscriptionId'?: string;
    'currentPeriodStartAt'?: Date;
    'currentPeriodEndAt'?: Date;
    'canceled'?: boolean;
    'cancelAtPeriodEnd'?: boolean;
    'trialEnd'?: Date;
    'status'?: Subscription.StatusEnum;
    'createdAt'?: Date;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "stripeSubscriptionId",
            "baseName": "stripe_subscription_id",
            "type": "string"
        },
        {
            "name": "currentPeriodStartAt",
            "baseName": "current_period_start_at",
            "type": "Date"
        },
        {
            "name": "currentPeriodEndAt",
            "baseName": "current_period_end_at",
            "type": "Date"
        },
        {
            "name": "canceled",
            "baseName": "canceled",
            "type": "boolean"
        },
        {
            "name": "cancelAtPeriodEnd",
            "baseName": "cancel_at_period_end",
            "type": "boolean"
        },
        {
            "name": "trialEnd",
            "baseName": "trial_end",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Subscription.StatusEnum"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Subscription.attributeTypeMap;
    }
}

export namespace Subscription {
    export enum StatusEnum {
        Trialing = <any> 'trialing',
        Active = <any> 'active',
        PastDue = <any> 'past_due',
        Unpaid = <any> 'unpaid',
        Canceled = <any> 'canceled'
    }
}
export class User {
    'id'?: number;
    'affiliateEnabled'?: boolean;
    'agreedTermsOfService'?: boolean;
    'authId'?: string;
    'authProvider'?: User.AuthProviderEnum;
    'email'?: string;
    'registrationNotified'?: boolean;
    'statistics'?: UserStatistics;
    'createdAt'?: Date;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "affiliateEnabled",
            "baseName": "affiliate_enabled",
            "type": "boolean"
        },
        {
            "name": "agreedTermsOfService",
            "baseName": "agreed_terms_of_service",
            "type": "boolean"
        },
        {
            "name": "authId",
            "baseName": "auth_id",
            "type": "string"
        },
        {
            "name": "authProvider",
            "baseName": "auth_provider",
            "type": "User.AuthProviderEnum"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "registrationNotified",
            "baseName": "registration_notified",
            "type": "boolean"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "UserStatistics"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export namespace User {
    export enum AuthProviderEnum {
        Auth0 = <any> 'auth0',
        Github = <any> 'github',
        Google = <any> 'google',
        Twitter = <any> 'twitter'
    }
}
export class UserStatistics {
    'registrationInvitationCount'?: number;
    'subscriptionInvitationCount'?: number;
    'masteringCount'?: number;
    'monthlyRegistrationInvitationCount'?: number;
    'monthlySubscriptionInvitationCount'?: number;
    'monthlyMasteringCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "registrationInvitationCount",
            "baseName": "registration_invitation_count",
            "type": "number"
        },
        {
            "name": "subscriptionInvitationCount",
            "baseName": "subscription_invitation_count",
            "type": "number"
        },
        {
            "name": "masteringCount",
            "baseName": "mastering_count",
            "type": "number"
        },
        {
            "name": "monthlyRegistrationInvitationCount",
            "baseName": "monthly_registration_invitation_count",
            "type": "number"
        },
        {
            "name": "monthlySubscriptionInvitationCount",
            "baseName": "monthly_subscription_invitation_count",
            "type": "number"
        },
        {
            "name": "monthlyMasteringCount",
            "baseName": "monthly_mastering_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UserStatistics.attributeTypeMap;
    }
}

export class Video {
    'id'?: number;
    'fileResourceId'?: number;
    'userId'?: number;
    'name'?: string;
    'createdAt'?: Date;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "fileResourceId",
            "baseName": "file_resource_id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Video.attributeTypeMap;
    }
}

export class VideoDownloadToken {
    'downloadToken'?: JWT;
    'downloadUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "downloadToken",
            "baseName": "download_token",
            "type": "JWT"
        },
        {
            "name": "downloadUrl",
            "baseName": "download_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VideoDownloadToken.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "AmazonSubscription.StatusEnum": AmazonSubscription.StatusEnum,
        "AnonymizedMastering.ModeEnum": AnonymizedMastering.ModeEnum,
        "AnonymizedMastering.StatusEnum": AnonymizedMastering.StatusEnum,
        "AnonymizedMastering.FailureReasonEnum": AnonymizedMastering.FailureReasonEnum,
        "AnonymizedMastering.OutputFormatEnum": AnonymizedMastering.OutputFormatEnum,
        "AnonymizedMastering.PresetEnum": AnonymizedMastering.PresetEnum,
        "AnonymizedMastering.PaymentServiceEnum": AnonymizedMastering.PaymentServiceEnum,
        "Mastering.ModeEnum": Mastering.ModeEnum,
        "Mastering.StatusEnum": Mastering.StatusEnum,
        "Mastering.FailureReasonEnum": Mastering.FailureReasonEnum,
        "Mastering.TargetLoudnessModeEnum": Mastering.TargetLoudnessModeEnum,
        "Mastering.OutputFormatEnum": Mastering.OutputFormatEnum,
        "Mastering.PresetEnum": Mastering.PresetEnum,
        "Mastering.MasteringAlgorithmEnum": Mastering.MasteringAlgorithmEnum,
        "Mastering.VideoStatusEnum": Mastering.VideoStatusEnum,
        "Payment.ServiceEnum": Payment.ServiceEnum,
        "Plan.CurrencyEnum": Plan.CurrencyEnum,
        "Plan.IntervalEnum": Plan.IntervalEnum,
        "SpSubscription.StatusEnum": SpSubscription.StatusEnum,
        "Subscription.StatusEnum": Subscription.StatusEnum,
        "User.AuthProviderEnum": User.AuthProviderEnum,
}

let typeMap: {[index: string]: any} = {
    "AccessToken": AccessToken,
    "AmazonSubscription": AmazonSubscription,
    "AnonymizedMastering": AnonymizedMastering,
    "Audio": Audio,
    "AudioAnalysis": AudioAnalysis,
    "AudioDownloadToken": AudioDownloadToken,
    "Config": Config,
    "ConfigAuth0": ConfigAuth0,
    "ConfigPaypal": ConfigPaypal,
    "ConfigStripe": ConfigStripe,
    "ConfigVersion": ConfigVersion,
    "ExternalSearchResult": ExternalSearchResult,
    "ExternalSearchResultItunes": ExternalSearchResultItunes,
    "ExternalSearchResultYoutube": ExternalSearchResultYoutube,
    "GroupBuyStatistics": GroupBuyStatistics,
    "JWT": JWT,
    "Kpi": Kpi,
    "LibraryAudio": LibraryAudio,
    "LibraryAudioAnalysis": LibraryAudioAnalysis,
    "LibraryAudioLike": LibraryAudioLike,
    "Mastering": Mastering,
    "Payment": Payment,
    "PaymentCustomer": PaymentCustomer,
    "Plan": Plan,
    "SpSubscription": SpSubscription,
    "Subscription": Subscription,
    "User": User,
    "UserStatistics": UserStatistics,
    "Video": Video,
    "VideoDownloadToken": VideoDownloadToken,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccessTokenApiApiKeys {
    bearer,
}

export class AccessTokenApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccessTokenApiApiKeys, value: string) {
        (this.authentications as any)[AccessTokenApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create an API access token.
     * @param {*} [options] Override http request options.
     */
    public createAccessToken (options: any = {}) : Promise<{ response: http.ClientResponse; body: AccessToken;  }> {
        const localVarPath = this.basePath + '/access_tokens';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccessToken;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessToken");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AmazonSubscriptionApiApiKeys {
    bearer,
}

export class AmazonSubscriptionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AmazonSubscriptionApiApiKeys, value: string) {
        (this.authentications as any)[AmazonSubscriptionApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get all accessable amazon subscriptions.
     * @param {*} [options] Override http request options.
     */
    public listAmazonSubscriptions (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<AmazonSubscription>;  }> {
        const localVarPath = this.basePath + '/amazon_subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<AmazonSubscription>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AmazonSubscription>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AudioApiApiKeys {
    bearer,
}

export class AudioApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AudioApiApiKeys, value: string) {
        (this.authentications as any)[AudioApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new audio.
     * @param file The file to upload.
     * @param name Audio name. If this is not specified, the name in file parameter is used.
     * @param {*} [options] Override http request options.
     */
    public createAudio (file?: Buffer, name?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Audio;  }> {
        const localVarPath = this.basePath + '/audios';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Audio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Audio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Download an audio data by id.
     * @param id Audio id
     * @param {*} [options] Override http request options.
     */
    public downloadAudio (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/audios/{id}/download'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling downloadAudio.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Download an audio data by audio_download_token.
     * @param downloadToken Audio download token
     * @param {*} [options] Override http request options.
     */
    public downloadAudioByToken (downloadToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/audios/download_by_token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'downloadToken' is not null or undefined
        if (downloadToken === null || downloadToken === undefined) {
            throw new Error('Required parameter downloadToken was null or undefined when calling downloadAudioByToken.');
        }

        if (downloadToken !== undefined) {
            localVarQueryParameters['download_token'] = ObjectSerializer.serialize(downloadToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an audio by id.
     * @param id Audio id
     * @param {*} [options] Override http request options.
     */
    public getAudio (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Audio;  }> {
        const localVarPath = this.basePath + '/audios/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAudio.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Audio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Audio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an audio analysis by id.
     * @param id Audio id
     * @param {*} [options] Override http request options.
     */
    public getAudioAnalysis (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: AudioAnalysis;  }> {
        const localVarPath = this.basePath + '/audios/{id}/analysis'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAudioAnalysis.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AudioAnalysis;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AudioAnalysis");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an audio download token by id.
     * @param id Audio id
     * @param {*} [options] Override http request options.
     */
    public getAudioDownloadToken (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: AudioDownloadToken;  }> {
        const localVarPath = this.basePath + '/audios/{id}/download_token'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAudioDownloadToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AudioDownloadToken;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AudioDownloadToken");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all audios accessable.
     * @param {*} [options] Override http request options.
     */
    public listAudios (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Audio>;  }> {
        const localVarPath = this.basePath + '/audios';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Audio>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Audio>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConfigApiApiKeys {
    bearer,
}

export class ConfigApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ConfigApiApiKeys, value: string) {
        (this.authentications as any)[ConfigApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get config.
     * @param {*} [options] Override http request options.
     */
    public getConfig (options: any = {}) : Promise<{ response: http.ClientResponse; body: Config;  }> {
        const localVarPath = this.basePath + '/config';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Config;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Config");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExternalSearchApiApiKeys {
    bearer,
}

export class ExternalSearchApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExternalSearchApiApiKeys, value: string) {
        (this.authentications as any)[ExternalSearchApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Search external music and get name, url, thumbnails, etc.
     * @param query Search query
     * @param country Country ex. US, JP, etc
     * @param {*} [options] Override http request options.
     */
    public searchExternal (query: string, country: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ExternalSearchResult;  }> {
        const localVarPath = this.basePath + '/external_search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling searchExternal.');
        }

        // verify required parameter 'country' is not null or undefined
        if (country === null || country === undefined) {
            throw new Error('Required parameter country was null or undefined when calling searchExternal.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExternalSearchResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExternalSearchResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LibraryAudioApiApiKeys {
    bearer,
}

export class LibraryAudioApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LibraryAudioApiApiKeys, value: string) {
        (this.authentications as any)[LibraryAudioApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new library audio.
     * @param file The file to upload.
     * @param {*} [options] Override http request options.
     */
    public createLibraryAudio (file?: Buffer, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryAudio;  }> {
        const localVarPath = this.basePath + '/library_audios';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryAudio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryAudio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new library audio like.
     * @param id Library audio id
     * @param {*} [options] Override http request options.
     */
    public createLibraryAudioLike (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryAudioLike;  }> {
        const localVarPath = this.basePath + '/library_audios/{id}/like'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createLibraryAudioLike.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryAudioLike;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryAudioLike");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete library audio.
     * @param id Library audio id
     * @param {*} [options] Override http request options.
     */
    public deleteLibraryAudio (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryAudio;  }> {
        const localVarPath = this.basePath + '/library_audios/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteLibraryAudio.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryAudio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryAudio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a library audio by id.
     * @param id Library audio id
     * @param {*} [options] Override http request options.
     */
    public getLibraryAudio (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryAudio;  }> {
        const localVarPath = this.basePath + '/library_audios/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLibraryAudio.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryAudio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryAudio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a library audio analysis by id.
     * @param id Library audio id
     * @param {*} [options] Override http request options.
     */
    public getLibraryAudioAnalysis (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryAudioAnalysis;  }> {
        const localVarPath = this.basePath + '/library_audios/{id}/analysis'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLibraryAudioAnalysis.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryAudioAnalysis;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryAudioAnalysis");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all library audios accessable.
     * @param {*} [options] Override http request options.
     */
    public listLibraryAudios (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<LibraryAudio>;  }> {
        const localVarPath = this.basePath + '/library_audios';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<LibraryAudio>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LibraryAudio>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update library audio.
     * @param id Library audio id
     * @param isPublic Whether the library audio is public.
     * @param {*} [options] Override http request options.
     */
    public updateLibraryAudio (id: number, isPublic?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryAudio;  }> {
        const localVarPath = this.basePath + '/library_audios/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateLibraryAudio.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (isPublic !== undefined) {
            localVarFormParams['is_public'] = ObjectSerializer.serialize(isPublic, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryAudio;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryAudio");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MasteringApiApiKeys {
    bearer,
}

export class MasteringApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MasteringApiApiKeys, value: string) {
        (this.authentications as any)[MasteringApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Cancel a mastering by id.
     * @param id Mastering id
     * @param {*} [options] Override http request options.
     */
    public cancelMastering (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mastering;  }> {
        const localVarPath = this.basePath + '/masterings/{id}/cancel'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling cancelMastering.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mastering;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mastering");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new mastering.
     * @param inputAudioId Input audio id
     * @param mode Mode
     * @param bassPreservation This parameter represents if the bass preservation is enabled.
     * @param mastering This parameter represents if the mastering is enabled. This parameter is effective only when the mode is \&quot;default\&quot; or \&quot;custom\&quot;.
     * @param masteringAlgorithm 
     * @param noiseReduction This parameter represents if the nosie reduction is enabled. This parameter is effective only when the mode is \&quot;custom\&quot;.
     * @param preset This parameter is effective only when the mode is \&quot;custom\&quot;.
     * @param targetLoudness This parameter represents the target loudness of the output audio in dB. This parameter is effective only when the mode is \&quot;custom\&quot;.
     * @param targetLoudnessMode 
     * @param masteringMatchingLevel This parameter represents the mastering reference matching level. This parameter is effective only when the mode is \&quot;custom\&quot; and the mastering is enabled.
     * @param masteringReverb This parameter represents if the mastering reverb is enabled. This parameter is effective only when the mode is \&quot;custom\&quot; and the mastering is enabled.
     * @param masteringReverbGain This parameter represents the mastering reverb gain relative to the dry sound in dB. This parameter is effective only when the mode is \&quot;custom\&quot; and the mastering is \&quot;true\&quot; and the mastering_reverb is \&quot;true\&quot;.
     * @param referenceAudioId Reference audio id. This parameter is effective only when the mode is \&quot;custom\&quot; and the mastering is enabled.
     * @param lowCutFreq This parameter represents the low cut freq  of the output audio in Hz. This parameter is effective only when the mode is \&quot;custom\&quot;.
     * @param highCutFreq This parameter represents the high cut freq of the output audio in Hz. This parameter is effective only when the mode is \&quot;custom\&quot;.
     * @param ceiling 
     * @param ceilingMode 
     * @param oversample 
     * @param sampleRate This parameter represents the sample rate of the output audio in dB. This parameter is effective only when the mode is \&quot;custom\&quot;.
     * @param bitDepth This parameter represents the bit depth of the output audio in dB. This parameter is effective only when the mode is \&quot;custom\&quot;.
     * @param outputFormat This parameter represents the format of the output audio. This parameter is effective only when the mode is \&quot;custom\&quot;.
     * @param forPreview If this is true, the mastering is treated for preview purpose (ex. not purchasable, not publishable, short lifetime). 
     * @param startAt Partial mastering start at. 
     * @param endAt Partial mastering end at. 
     * @param videoTitle This parameter represents the title of output video.
     * @param {*} [options] Override http request options.
     */
    public createMastering (inputAudioId: number, mode?: 'default' | 'custom', bassPreservation?: boolean, mastering?: boolean, masteringAlgorithm?: 'v1' | 'v2', noiseReduction?: boolean, preset?: 'general' | 'pop' | 'classical' | 'jazz', targetLoudness?: number, targetLoudnessMode?: 'loudness' | 'rms' | 'peak' | 'youtube_loudness', masteringMatchingLevel?: number, masteringReverb?: boolean, masteringReverbGain?: number, referenceAudioId?: number, lowCutFreq?: number, highCutFreq?: number, ceiling?: number, ceilingMode?: 'peak' | 'true_peak' | 'lowpass_true_peak', oversample?: number, sampleRate?: number, bitDepth?: number, outputFormat?: 'wav' | 'mp3', forPreview?: boolean, startAt?: number, endAt?: number, videoTitle?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mastering;  }> {
        const localVarPath = this.basePath + '/masterings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'inputAudioId' is not null or undefined
        if (inputAudioId === null || inputAudioId === undefined) {
            throw new Error('Required parameter inputAudioId was null or undefined when calling createMastering.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (mode !== undefined) {
            localVarFormParams['mode'] = ObjectSerializer.serialize(mode, "'default' | 'custom'");
        }

        if (inputAudioId !== undefined) {
            localVarFormParams['input_audio_id'] = ObjectSerializer.serialize(inputAudioId, "number");
        }

        if (bassPreservation !== undefined) {
            localVarFormParams['bass_preservation'] = ObjectSerializer.serialize(bassPreservation, "boolean");
        }

        if (mastering !== undefined) {
            localVarFormParams['mastering'] = ObjectSerializer.serialize(mastering, "boolean");
        }

        if (masteringAlgorithm !== undefined) {
            localVarFormParams['mastering_algorithm'] = ObjectSerializer.serialize(masteringAlgorithm, "'v1' | 'v2'");
        }

        if (noiseReduction !== undefined) {
            localVarFormParams['noise_reduction'] = ObjectSerializer.serialize(noiseReduction, "boolean");
        }

        if (preset !== undefined) {
            localVarFormParams['preset'] = ObjectSerializer.serialize(preset, "'general' | 'pop' | 'classical' | 'jazz'");
        }

        if (targetLoudness !== undefined) {
            localVarFormParams['target_loudness'] = ObjectSerializer.serialize(targetLoudness, "number");
        }

        if (targetLoudnessMode !== undefined) {
            localVarFormParams['target_loudness_mode'] = ObjectSerializer.serialize(targetLoudnessMode, "'loudness' | 'rms' | 'peak' | 'youtube_loudness'");
        }

        if (masteringMatchingLevel !== undefined) {
            localVarFormParams['mastering_matching_level'] = ObjectSerializer.serialize(masteringMatchingLevel, "number");
        }

        if (masteringReverb !== undefined) {
            localVarFormParams['mastering_reverb'] = ObjectSerializer.serialize(masteringReverb, "boolean");
        }

        if (masteringReverbGain !== undefined) {
            localVarFormParams['mastering_reverb_gain'] = ObjectSerializer.serialize(masteringReverbGain, "number");
        }

        if (referenceAudioId !== undefined) {
            localVarFormParams['reference_audio_id'] = ObjectSerializer.serialize(referenceAudioId, "number");
        }

        if (lowCutFreq !== undefined) {
            localVarFormParams['low_cut_freq'] = ObjectSerializer.serialize(lowCutFreq, "number");
        }

        if (highCutFreq !== undefined) {
            localVarFormParams['high_cut_freq'] = ObjectSerializer.serialize(highCutFreq, "number");
        }

        if (ceiling !== undefined) {
            localVarFormParams['ceiling'] = ObjectSerializer.serialize(ceiling, "number");
        }

        if (ceilingMode !== undefined) {
            localVarFormParams['ceiling_mode'] = ObjectSerializer.serialize(ceilingMode, "'peak' | 'true_peak' | 'lowpass_true_peak'");
        }

        if (oversample !== undefined) {
            localVarFormParams['oversample'] = ObjectSerializer.serialize(oversample, "number");
        }

        if (sampleRate !== undefined) {
            localVarFormParams['sample_rate'] = ObjectSerializer.serialize(sampleRate, "number");
        }

        if (bitDepth !== undefined) {
            localVarFormParams['bit_depth'] = ObjectSerializer.serialize(bitDepth, "number");
        }

        if (outputFormat !== undefined) {
            localVarFormParams['output_format'] = ObjectSerializer.serialize(outputFormat, "'wav' | 'mp3'");
        }

        if (forPreview !== undefined) {
            localVarFormParams['for_preview'] = ObjectSerializer.serialize(forPreview, "boolean");
        }

        if (startAt !== undefined) {
            localVarFormParams['start_at'] = ObjectSerializer.serialize(startAt, "number");
        }

        if (endAt !== undefined) {
            localVarFormParams['end_at'] = ObjectSerializer.serialize(endAt, "number");
        }

        if (videoTitle !== undefined) {
            localVarFormParams['video_title'] = ObjectSerializer.serialize(videoTitle, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mastering;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mastering");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete mastering.
     * @param id Mastering id
     * @param {*} [options] Override http request options.
     */
    public deleteMastering (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mastering;  }> {
        const localVarPath = this.basePath + '/masterings/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteMastering.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mastering;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mastering");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Free unlock a mastering by id.
     * @param id Mastering id
     * @param {*} [options] Override http request options.
     */
    public freeUnlockMastering (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mastering;  }> {
        const localVarPath = this.basePath + '/masterings/{id}/free_unlock'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling freeUnlockMastering.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mastering;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mastering");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a mastering by id.
     * @param id Mastering id
     * @param {*} [options] Override http request options.
     */
    public getMastering (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mastering;  }> {
        const localVarPath = this.basePath + '/masterings/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMastering.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mastering;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mastering");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Review a mastering by id.
     * @param id Mastering id
     * @param {*} [options] Override http request options.
     */
    public getMasteringUnlockProduct (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mastering;  }> {
        const localVarPath = this.basePath + '/masterings/{id}/unlock_product'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMasteringUnlockProduct.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mastering;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mastering");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all accessable masterings.
     * @param {*} [options] Override http request options.
     */
    public listMasterings (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Mastering>;  }> {
        const localVarPath = this.basePath + '/masterings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Mastering>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Mastering>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Publish a mastering by id.
     * @param id Mastering id
     * @param accessToken This parameter represents if the access token of the publishment service API.
     * @param message This parameter represents the publishment message.
     * @param service This parameter represents the publishment service.
     * @param accessTokenSecret This parameter represents the access token secret of the publishment service API. This parameter is effective only when the service is \&quot;twitter\&quot;.
     * @param {*} [options] Override http request options.
     */
    public publishMastering (id: number, accessToken: string, message: string, service?: 'twitter' | 'youtube', accessTokenSecret?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mastering;  }> {
        const localVarPath = this.basePath + '/masterings/{id}/publish'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling publishMastering.');
        }

        // verify required parameter 'accessToken' is not null or undefined
        if (accessToken === null || accessToken === undefined) {
            throw new Error('Required parameter accessToken was null or undefined when calling publishMastering.');
        }

        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling publishMastering.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (service !== undefined) {
            localVarFormParams['service'] = ObjectSerializer.serialize(service, "'twitter' | 'youtube'");
        }

        if (accessToken !== undefined) {
            localVarFormParams['access_token'] = ObjectSerializer.serialize(accessToken, "string");
        }

        if (accessTokenSecret !== undefined) {
            localVarFormParams['access_token_secret'] = ObjectSerializer.serialize(accessTokenSecret, "string");
        }

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mastering;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mastering");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Review a mastering by id.
     * @param id Mastering id
     * @param reviewComment This parameter represents the review comment.
     * @param reviewScore This parameter represents the review score.
     * @param {*} [options] Override http request options.
     */
    public reviewMastering (id: number, reviewComment?: string, reviewScore?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mastering;  }> {
        const localVarPath = this.basePath + '/masterings/{id}/review'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reviewMastering.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (reviewComment !== undefined) {
            localVarFormParams['review_comment'] = ObjectSerializer.serialize(reviewComment, "string");
        }

        if (reviewScore !== undefined) {
            localVarFormParams['review_score'] = ObjectSerializer.serialize(reviewScore, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mastering;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mastering");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a mastering.
     * @param id Mastering id
     * @param preserved Disable auto delete.
     * @param {*} [options] Override http request options.
     */
    public updateMastering (id: number, preserved?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Mastering;  }> {
        const localVarPath = this.basePath + '/masterings/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMastering.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (preserved !== undefined) {
            localVarFormParams['preserved'] = ObjectSerializer.serialize(preserved, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Mastering;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Mastering");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentApiApiKeys {
    bearer,
}

export class PaymentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentApiApiKeys, value: string) {
        (this.authentications as any)[PaymentApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new payment.
     * @param productToken This parameter represents the product token.
     * @param service This parameter represents the payment message.
     * @param token This parameter represents the card token. This parameter is effective only when the service is \&quot;stripe\&quot;.
     * @param {*} [options] Override http request options.
     */
    public createPayment (productToken: string, service: 'paypal' | 'stripe', token?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Payment;  }> {
        const localVarPath = this.basePath + '/payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'productToken' is not null or undefined
        if (productToken === null || productToken === undefined) {
            throw new Error('Required parameter productToken was null or undefined when calling createPayment.');
        }

        // verify required parameter 'service' is not null or undefined
        if (service === null || service === undefined) {
            throw new Error('Required parameter service was null or undefined when calling createPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (productToken !== undefined) {
            localVarFormParams['product_token'] = ObjectSerializer.serialize(productToken, "string");
        }

        if (service !== undefined) {
            localVarFormParams['service'] = ObjectSerializer.serialize(service, "'paypal' | 'stripe'");
        }

        if (token !== undefined) {
            localVarFormParams['token'] = ObjectSerializer.serialize(token, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Payment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Payment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Execute a payment by id.
     * @param id Payment id
     * @param payerId This parameter represents the card token. This parameter is effective only when the service is \&quot;paypal\&quot;.
     * @param {*} [options] Override http request options.
     */
    public executePayment (id: number, payerId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Payment;  }> {
        const localVarPath = this.basePath + '/payments/{id}/execute'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling executePayment.');
        }

        // verify required parameter 'payerId' is not null or undefined
        if (payerId === null || payerId === undefined) {
            throw new Error('Required parameter payerId was null or undefined when calling executePayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (payerId !== undefined) {
            localVarFormParams['payer_id'] = ObjectSerializer.serialize(payerId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Payment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Payment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a payment by id.
     * @param id Payment id
     * @param {*} [options] Override http request options.
     */
    public getPayment (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Payment;  }> {
        const localVarPath = this.basePath + '/payments/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Payment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Payment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all accessable payments.
     * @param {*} [options] Override http request options.
     */
    public listPayments (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Payment>;  }> {
        const localVarPath = this.basePath + '/payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Payment>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Payment>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentCustomerApiApiKeys {
    bearer,
}

export class PaymentCustomerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentCustomerApiApiKeys, value: string) {
        (this.authentications as any)[PaymentCustomerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get a default payment customer.
     * @param {*} [options] Override http request options.
     */
    public getDefaultPaymentCustomer (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PaymentCustomer>;  }> {
        const localVarPath = this.basePath + '/payment_customers/default';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PaymentCustomer>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PaymentCustomer>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PlanApiApiKeys {
    bearer,
}

export class PlanApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PlanApiApiKeys, value: string) {
        (this.authentications as any)[PlanApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get all accessable plans.
     * @param {*} [options] Override http request options.
     */
    public listPlans (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Plan>;  }> {
        const localVarPath = this.basePath + '/plans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Plan>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Plan>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SpSubscriptionApiApiKeys {
    bearer,
}

export class SpSubscriptionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SpSubscriptionApiApiKeys, value: string) {
        (this.authentications as any)[SpSubscriptionApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a new smartphone subscription.
     * @param service Service.
     * @param receipt Base64 encoded app store receipt. This parameter is effective only when the service is \&quot;appstore\&quot;.
     * @param {*} [options] Override http request options.
     */
    public createSpSubscription (service: 'appstore', receipt?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SpSubscription;  }> {
        const localVarPath = this.basePath + '/sp_subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'service' is not null or undefined
        if (service === null || service === undefined) {
            throw new Error('Required parameter service was null or undefined when calling createSpSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (service !== undefined) {
            localVarFormParams['service'] = ObjectSerializer.serialize(service, "'appstore'");
        }

        if (receipt !== undefined) {
            localVarFormParams['receipt'] = ObjectSerializer.serialize(receipt, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SpSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SpSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all accessable smartphone subscriptions.
     * @param {*} [options] Override http request options.
     */
    public listSpSubscriptions (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<SpSubscription>;  }> {
        const localVarPath = this.basePath + '/sp_subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SpSubscription>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SpSubscription>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StatisticsApiApiKeys {
    bearer,
}

export class StatisticsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StatisticsApiApiKeys, value: string) {
        (this.authentications as any)[StatisticsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get group buy statistics.
     * @param {*} [options] Override http request options.
     */
    public getGroupBuyStatistics (options: any = {}) : Promise<{ response: http.ClientResponse; body: GroupBuyStatistics;  }> {
        const localVarPath = this.basePath + '/statistics/group_buy';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupBuyStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GroupBuyStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get anonymized masterings.
     * @param {*} [options] Override http request options.
     */
    public listAnonymizedMasterings (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<AnonymizedMastering>;  }> {
        const localVarPath = this.basePath + '/statistics/anonymized_masterings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<AnonymizedMastering>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AnonymizedMastering>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get KPIs.
     * @param {*} [options] Override http request options.
     */
    public listKpis (options: any = {}) : Promise<{ response: http.ClientResponse; body: Kpi;  }> {
        const localVarPath = this.basePath + '/statistics/kpis';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Kpi;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Kpi");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubscriptionApiApiKeys {
    bearer,
}

export class SubscriptionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubscriptionApiApiKeys, value: string) {
        (this.authentications as any)[SubscriptionApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Cancel a subscription by id.
     * @param id Subscription id
     * @param {*} [options] Override http request options.
     */
    public cancelSubscription (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Subscription;  }> {
        const localVarPath = this.basePath + '/subscriptions/{id}/cancel'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling cancelSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Subscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Subscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Cancel the subscription cancellation  by id.
     * @param id Subscription id
     * @param {*} [options] Override http request options.
     */
    public cancelSubscriptionCancellation (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Subscription;  }> {
        const localVarPath = this.basePath + '/subscriptions/{id}/cancel_cancellation'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling cancelSubscriptionCancellation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Subscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Subscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new subscription.
     * @param service This parameter represents the payment message.
     * @param stripePlanId The Stripe plan id. This parameter is effective only when the service is \&quot;stripe\&quot;.
     * @param token This parameter represents the card token. This parameter is effective only when the service is \&quot;stripe\&quot;.
     * @param affiliateId Affiliate id of inviter user.
     * @param {*} [options] Override http request options.
     */
    public createSubscription (service: 'stripe', stripePlanId?: string, token?: string, affiliateId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Subscription;  }> {
        const localVarPath = this.basePath + '/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'service' is not null or undefined
        if (service === null || service === undefined) {
            throw new Error('Required parameter service was null or undefined when calling createSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (service !== undefined) {
            localVarFormParams['service'] = ObjectSerializer.serialize(service, "'stripe'");
        }

        if (stripePlanId !== undefined) {
            localVarFormParams['stripe_plan_id'] = ObjectSerializer.serialize(stripePlanId, "string");
        }

        if (token !== undefined) {
            localVarFormParams['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (affiliateId !== undefined) {
            localVarFormParams['affiliate_id'] = ObjectSerializer.serialize(affiliateId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Subscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Subscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a subscription by id.
     * @param id Subscription id
     * @param {*} [options] Override http request options.
     */
    public getSubscription (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Subscription;  }> {
        const localVarPath = this.basePath + '/subscriptions/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Subscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Subscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all accessable subscriptions.
     * @param {*} [options] Override http request options.
     */
    public listSubscriptions (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Subscription>;  }> {
        const localVarPath = this.basePath + '/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Subscription>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Subscription>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserApiApiKeys {
    bearer,
}

export class UserApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get self user.
     * @param {*} [options] Override http request options.
     */
    public getSelf (options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/self';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Notify user is registered.
     * @param affiliateId The affiliate id of inviter.
     * @param referrerUrl The referrer URL.
     * @param {*} [options] Override http request options.
     */
    public notifyRegistration (affiliateId?: string, referrerUrl?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/self/notify_registration';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (affiliateId !== undefined) {
            localVarFormParams['affiliate_id'] = ObjectSerializer.serialize(affiliateId, "string");
        }

        if (referrerUrl !== undefined) {
            localVarFormParams['referrer_url'] = ObjectSerializer.serialize(referrerUrl, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send invitation.
     * @param inviteeEmail The email of invitee.
     * @param {*} [options] Override http request options.
     */
    public sendInvitation (inviteeEmail: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/self/send_invitation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'inviteeEmail' is not null or undefined
        if (inviteeEmail === null || inviteeEmail === undefined) {
            throw new Error('Required parameter inviteeEmail was null or undefined when calling sendInvitation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (inviteeEmail !== undefined) {
            localVarFormParams['invitee_email'] = ObjectSerializer.serialize(inviteeEmail, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update self user.
     * @param agreedTermsOfService Whether you agreed terms of service.
     * @param email The email.
     * @param {*} [options] Override http request options.
     */
    public updateSelf (agreedTermsOfService?: boolean, email?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/self';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (agreedTermsOfService !== undefined) {
            localVarFormParams['agreed_terms_of_service'] = ObjectSerializer.serialize(agreedTermsOfService, "boolean");
        }

        if (email !== undefined) {
            localVarFormParams['email'] = ObjectSerializer.serialize(email, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VideoApiApiKeys {
    bearer,
}

export class VideoApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VideoApiApiKeys, value: string) {
        (this.authentications as any)[VideoApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Download an video data by id.
     * @param id Video id
     * @param {*} [options] Override http request options.
     */
    public downloadVideo (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/videos/{id}/download'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling downloadVideo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Download an video data by video_download_token.
     * @param downloadToken Video download token
     * @param {*} [options] Override http request options.
     */
    public downloadVideoByToken (downloadToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/videos/download_by_token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'downloadToken' is not null or undefined
        if (downloadToken === null || downloadToken === undefined) {
            throw new Error('Required parameter downloadToken was null or undefined when calling downloadVideoByToken.');
        }

        if (downloadToken !== undefined) {
            localVarQueryParameters['download_token'] = ObjectSerializer.serialize(downloadToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an video by id.
     * @param id Video id
     * @param {*} [options] Override http request options.
     */
    public getVideo (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Video;  }> {
        const localVarPath = this.basePath + '/videos/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVideo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Video;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Video");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an video download token by id.
     * @param id Video id
     * @param {*} [options] Override http request options.
     */
    public getVideoDownloadToken (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: VideoDownloadToken;  }> {
        const localVarPath = this.basePath + '/videos/{id}/download_token'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVideoDownloadToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VideoDownloadToken;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VideoDownloadToken");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all videos accessable.
     * @param {*} [options] Override http request options.
     */
    public listVideos (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Video>;  }> {
        const localVarPath = this.basePath + '/videos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Video>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Video>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
